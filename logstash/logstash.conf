input {
  jdbc {
    jdbc_connection_string => "jdbc:mysql://${JDBC_HOST}:${JDBC_PORT}/${JDBC_DATABASE}"
    jdbc_user => "${JDBC_USER}"
    jdbc_password => "${JDBC_PASSWORD}"
    jdbc_driver_library => "${JDBC_DRIVER_LIBRARY}"
    jdbc_driver_class => "${JDBC_DRIVER_CLASS}"
    statement => "select distinct OrderId, ParentOrderId, OrderBillAmount, UpdatedDate, MobileNo, EmailId, FullName, FName, DisplayName, 
					OrderStatusId, OrderPlacedBy, GoogleRegId, OrderType, PaymentType, OnlineRefund, WalletRefund, 
					CASE 
					  WHEN OrderStatusId = 1 THEN 'order_placed'
					  WHEN OrderStatusId = 2 THEN 'order_confirmed'
					  WHEN OrderStatusId = 4 THEN 'order_shipped'
					  WHEN OrderStatusId = 5 THEN 'order_delivered'
					  WHEN OrderStatusId = 8 THEN 'order_cancelled'
					  ELSE 'unknown_status'
					END AS message_key
					from SSSPL.Orders_OrderDetails
					where OrderSTatusId IN (1,2,4,5,8)
					and UpdatedDate > :sql_last_value Order By UpdatedDate ASC
					"
    use_column_value => true
    tracking_column => "updateddate"
    tracking_column_type => "timestamp"
    clean_run => false
    schedule => "* * * * *" # Runs every minute
    last_run_metadata_path => "/usr/share/logstash/.logstash_orders_last_run"
    tags => ["order_details"]
  }

  jdbc {
    jdbc_connection_string => "jdbc:mysql://${JDBC_HOST}:${JDBC_PORT}/${JDBC_DATABASE}"
    jdbc_user => "${JDBC_USER}"
    jdbc_password => "${JDBC_PASSWORD}"
    jdbc_driver_library => "${JDBC_DRIVER_LIBRARY}"
    jdbc_driver_class => "${JDBC_DRIVER_CLASS}"
    statement => "select OrderId, OnlineRefund, WalletRefund, CODAmount, MobileNo, FName, DisplayName, 
                  UpdatedDate, GoogleRegId, EmailId, PaymentType, 'order_edit' as message_key from Orders_OrderEdit
					        where UpdatedDate > :sql_last_value Order By UpdatedDate ASC
					      "
    use_column_value => true
    tracking_column => "updateddate"
    tracking_column_type => "timestamp"
    clean_run => false
    schedule => "* * * * *" # Runs every minute
    last_run_metadata_path => "/usr/share/logstash/.logstash_orders_edit_last_run"
    tags => ["order_edit"]
  }

  jdbc {
    jdbc_connection_string => "jdbc:mysql://${JDBC_HOST}:${JDBC_PORT}/${JDBC_DATABASE}"
    jdbc_user => "${JDBC_USER}"
    jdbc_password => "${JDBC_PASSWORD}"
    jdbc_driver_library => "${JDBC_DRIVER_LIBRARY}"
    jdbc_driver_class => "${JDBC_DRIVER_CLASS}"
    statement => "select distinct pr.ProductName,pr.CustName,pr.CustMobile,pr.CustUserId,gcm.GoogleRegId, 'product_request' as message_key
                  FROM UserCommunication.tblProductRequest pr
                  LEFT JOIN 
                  (
                  SELECT gmcf.UserId,GoogleRegId FROM SiteManagement.tblMobileAppGCMReg gmcf
                  INNER JOIN 
                      (
                      SELECT UserId,MAX(GCMregId) AS GCMregId FROM
                      [SiteManagement].[tblMobileAppGCMReg]
                      WHERE IsActive=1
                      GROUP BY UserId
                      ) gcm on gmcf.GCMregId =gcm.GCMregId
                  )gcm on pr.CustUserId = gcm.UserId
                  WHERE pr.AvailableDate> :sql_last_value and pr.ProductRequestStatusMasId=3
                  AND CustUserId IS NOT NULL Order By AvailableDate ASC"
    use_column_value => true
    tracking_column => "updateddate"
    tracking_column_type => "timestamp"
    clean_run => false
    schedule => "* * * * *" # Runs every minute
    last_run_metadata_path => "/usr/share/logstash/.logstash_orders_edit_last_run"
    tags => ["order_edit"]
  }
}

filter {
  if "order_details" in [tags] {
    if [orderstatusid] == 1 {
      aggregate {
        task_id => "%{parentorderid}"
        code => "
          map['seen_orderids'] ||= []
          map['orderamount'] ||= 0.0

          unless map['seen_orderids'].include?(event.get('orderid'))
            map['orderamount'] += event.get('orderbillamount').to_f
            map['seen_orderids'] << event.get('orderid')
          end

          map['order_count'] ||= 0
          map['order_count'] += 1

          map['orderplacedby'] = event.get('orderplacedby')
          map['fname'] = event.get('fname')
          map['fullname'] = event.get('fullname')
          map['emailid'] = event.get('emailid')
          map['mobileno'] = event.get('mobileno')
          map['googleregid'] = event.get('googleregid')
          map['updateddate'] = event.get('updateddate')
          map['message_key'] = event.get('message_key')
          map['@timestamp'] = event.get('@timestamp')
          map['@version'] = event.get('@version')
          map['orderid'] = event.get('orderid')
          map['parentorderid'] ||= event.get('parentorderid')
          map['orderstatusid'] = event.get('orderstatusid')
          map['paymenttype']= event.get('paymenttype')
          map['ordertype'] = event.get('ordertype')
          map['onlinerefund'] = event.get('onlinerefund')
          map['walletrefund'] = event.get('walletrefund')

          map['products'] ||= []
          map['products'] << event.get('displayname')
        "
        push_map_as_event_on_timeout => true
        timeout => 60
        timeout_tags => ['_parent_aggregated']
        timeout_code => "
          event.set('orderplacedby', map['orderplacedby'])
          event.set('fname', map['fname'])
          event.set('fullname', map['fullname'])
          event.set('emailid', map['emailid'])
          event.set('mobileno', map['mobileno'])
          event.set('googleregid', map['googleregid'])
          event.set('updateddate', map['updateddate'])
          event.set('message_key', map['message_key'])
          event.set('@timestamp', map['@timestamp'])
          event.set('@version', map['@version'])
          event.set('orderid', map['orderid'])
          event.set('orderstatusid', map['orderstatusid'])
          event.set('products', map['products'])
          event.set('parentorderid', map['parentorderid'])
          event.set('orderamount', map['orderamount'])
          event.set('paymenttype', map['paymenttype'])
          event.set('ordertype', map['ordertype'])
          event.set('onlinerefund', map['onlinerefund'])
          event.set('walletrefund', map['walletrefund'])
        "
        timeout_task_id_field => "parentorder_agg_id"
      }

      mutate {
        add_field => {"parentorder_agg_id" => "%{parentorderid}" }
      }

      if "_parent_aggregated" not in [tags] {
        drop {}  # Drop intermediate events, only keep final sum event
      }
    }
    else{
      aggregate {
        task_id => "%{orderid}-%{orderstatusid}"
        code => "
          map['orderamount'] = event.get('orderbillamount')
          map['orderplacedby'] = event.get('orderplacedby')
          map['fname'] = event.get('fname')
          map['fullname'] = event.get('fullname')
          map['emailid'] = event.get('emailid')
          map['mobileno'] = event.get('mobileno')
          map['googleregid'] = event.get('googleregid')
          map['updateddate'] = event.get('updateddate')
          map['message_key'] = event.get('message_key')
          map['@timestamp'] = event.get('@timestamp')
          map['@version'] = event.get('@version')
          map['orderid'] = event.get('orderid')
          map['parentorderid'] = event.get('parentorderid')
          map['orderstatusid'] = event.get('orderstatusid')
          map['ordertype'] = event.get('ordertype')
          map['paymenttype'] = event.get('paymenttype')
          map['onlinerefund'] = event.get('onlinerefund')
          map['walletrefund'] = event.get('walletrefund')

          map['products'] ||= []
          map['products'] << event.get('displayname')
        "
        push_map_as_event_on_timeout => true
        timeout => 60
        timeout_tags => ['_aggregated']
        timeout_code => "
          event.set('orderplacedby', map['orderplacedby'])
          event.set('fname', map['fname'])
          event.set('fullname', map['fullname'])
          event.set('emailid', map['emailid'])
          event.set('mobileno', map['mobileno'])
          event.set('googleregid', map['googleregid'])
          event.set('updateddate', map['updateddate'])
          event.set('message_key', map['message_key'])
          event.set('@timestamp', map['@timestamp'])
          event.set('@version', map['@version'])
          event.set('orderid', map['orderid'])
          event.set('orderstatusid', map['orderstatusid'])
          event.set('products', map['products'])
          event.set('parentorderid', map['parentorderid'])
          event.set('orderamount', map['orderamount'])
          event.set('ordertype', map['ordertype'])
          event.set('paymenttype', map['paymenttype'])
          event.set('onlinerefund', map['onlinerefund'])
          event.set('walletrefund', map['walletrefund'])
        "
        timeout_task_id_field => "order_agg_id"
      }

      mutate {
        add_field => { "order_agg_id" => "%{orderid}-%{orderstatusid}" }
      }

      if "_aggregated" not in [tags] {
        drop {}
      }
    }
  }

  if "order_edit" in [tags] {
    aggregate {
      task_id => "%{orderid}"
      code => "
        map['fname'] = event.get('fname')
        map['fullname'] = event.get('fullname')
        map['emailid'] = event.get('emailid')
        map['mobileno'] = event.get('mobileno')
        map['googleregid'] = event.get('googleregid')
        map['updateddate'] = event.get('updateddate')
        map['message_key'] = event.get('message_key')
        map['@timestamp'] = event.get('@timestamp')
        map['@version'] = event.get('@version')
        map['orderid'] = event.get('orderid')
        map['onlinerefund'] = event.get('onlinerefund')
        map['walletrefund'] = event.get('walletrefund')
        map['codamount'] = event.get('codamount')
        map['paymenttype'] = event.get('paymenttype')

        map['products'] ||= []
        map['products'] << event.get('displayname')
      "
      push_map_as_event_on_timeout => true
      timeout => 60
      timeout_tags => ['_aggregated']
      timeout_code => "
        event.set('fname', map['fname'])
        event.set('fullname', map['fullname'])
        event.set('emailid', map['emailid'])
        event.set('mobileno', map['mobileno'])
        event.set('googleregid', map['googleregid'])
        event.set('updateddate', map['updateddate'])
        event.set('message_key', map['message_key'])
        event.set('@timestamp', map['@timestamp'])
        event.set('@version', map['@version'])
        event.set('orderid', map['orderid'])
        event.set('products', map['products'])
        event.set('onlinerefund', map['onlinerefund'])
        event.set('walletrefund', map['walletrefund'])
        event.set('codamount', map['codamount'])
        event.set('paymenttype', map['paymenttype'])
      "
      timeout_task_id_field => "order_edit_agg_id"
    }

    mutate {
      add_field => { "order_edit_agg_id" => "%{orderid}" }
    }

    if "_aggregated" not in [tags] {
      drop {}
    }
   }
}

output {
  stdout {
    codec => rubydebug
  }
  
  rabbitmq {
    host => "${RABBITMQ_HOST}"
    port => "${RABBITMQ_PORT}"
    user => "${RABBITMQ_USER}"
    password => "${RABBITMQ_PASSWORD}"
	exchange => "${EXCHANGE_NAME}"
    exchange_type => "direct"
	persistent => true
    durable => true
	key => "%{message_key}"
  }
}
